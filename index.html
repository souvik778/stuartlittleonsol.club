<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta Tags and Title -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StuartLittleOnSol Homepage</title>
    <meta name="$lilstu" content="StuartLittleOnSol">
    <link rel="icon" href="logo.jpg">
    
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

    <!-- Buffer Polyfill via UNPKG (buffer@5.7.1) -->
    <script src="https://cdn.jsdelivr.net/npm/buffer@5.7.1/index.js"></script>
   <script src="https://unpkg.com/@jup-ag/core@latest/dist/index.umd.js"></script>
<script src="https://unpkg.com/@jup-ag/wallet-adapter@latest/dist/index.umd.js"></script>
<script src="https://unpkg.com/@jup-ag/terminal@latest/dist/index.umd.js"></script>

    <!-- @solana/web3.js and @solana/spl-token ESM builds -->
    <script type="module">
        import { 
            Connection, 
            PublicKey, 
            clusterApiUrl, 
            LAMPORTS_PER_SOL, 
            SystemProgram, 
            Transaction 
        } from 'https://unpkg.com/@solana/web3.js@1.73.0/lib/index.esm.js';
        import * as splToken from 'https://unpkg.com/@solana/spl-token@0.4.9/lib/index.esm.js';
        
        // Assign to global window object
        window.solanaWeb3 = { 
            Connection, 
            PublicKey, 
            clusterApiUrl, 
            LAMPORTS_PER_SOL, 
            SystemProgram, 
            Transaction 
        };
        window.splToken = splToken;
    </script>

    <!-- Verification Script -->
    <script>
        // Ensure Buffer is defined
        window.Buffer = window.Buffer || Buffer;

        // Check if Buffer.from is working correctly
        console.log('Buffer is defined:', typeof Buffer !== 'undefined');
        if (typeof Buffer !== 'undefined') {
            console.log('Buffer.from works:', typeof Buffer.from === 'function');

            // If Buffer.from doesn't work as expected, provide a fallback implementation
            if (typeof Buffer.from !== 'function') {
                console.warn('Buffer.from is not defined or not working. Implementing a fallback.');
                Buffer.from = function (data, encoding) {
                    if (typeof data === 'string') {
                        switch (encoding) {
                            case 'utf8':
                            case 'utf-8':
                                return new Uint8Array(new TextEncoder().encode(data));
                            case 'hex':
                                return new Uint8Array(
                                    data.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
                                );
                            case 'base64':
                                return new Uint8Array(
                                    atob(data).split('').map((char) => char.charCodeAt(0))
                                );
                            default:
                                throw new Error('Unsupported encoding: ' + encoding);
                        }
                    } else if (Array.isArray(data) || data instanceof Uint8Array) {
                        return new Uint8Array(data);
                    } else {
                        throw new Error('Unsupported type for Buffer.from');
                    }
                };
            }
        }
    </script>

    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Font Awesome CDN for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
          integrity="sha512-pIVfEV+LlxG3XVvKxGlt5VxN8i3W2VllLkmE/1BjF8uPjnmFQjm25YMjRrI6QW+/KgeF95K5s1NVW8Vh4X4j4w=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap"
          rel="stylesheet">

    <!-- Link to External CSS -->
    <link rel="stylesheet" href="styles.css">

   <!--animate.css-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
          
    <style>
         h1 span.presale-live {
           
           color: #ab3219;
           text-shadow: 0 0 5px rgba(180, 104, 29, 0.6), 0 0 10px rgba(255, 47, 0, 0.4);
           font-size: inherit;
           font-weight: bold;
           cursor: pointer;
           transition: transform 2s, text-shadow 2s ease, color 2s ease;
       }

       /* Change color on hover */
       h1 span.presale-live:hover, 
       h1 span.presale-live:active {
           color: #FFD700; /* Warm gold color */ /* Light pink for interaction */
           transform: scale(1.05); /* Subtle scale-up */
           text-shadow: 0 0 8px rgba(255, 105, 180, 0.8), 0 0 15px rgba(255, 105, 180, 0.6);
       }

       /* Slight scale down on active (click/touch) */
       h1 span.presale-live:active {
           transform: scale(0.95);
       }
       .scroll-down-btn {
   margin-top: 20px;
   padding: 10px 15px;
   font-size: 1.2rem;
   background-color: #FFD700; /* Warm gold */
   color: #000;
   border: none;
   border-radius: 30px;
   cursor: pointer;
   transition: background-color 0.3s ease, transform 0.3s ease;
   text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);
   box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
   animation: bounce 2s infinite ease-in-out;
}

.scroll-down-btn:hover {
   background-color: #e6c200; /* Slightly darker gold */
   transform: scale(1.05); /* Subtle scale-up on hover */
   box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
}

.scroll-down-btn:active {
   transform: scale(0.95); /* Subtle scale-down on click */
}

@keyframes bounce {
   0%, 100% {
       transform: translateY(0);
   }
   50% {
       transform: translateY(-5px); /* Small upward bounce */
   }
}

    </style>
   
</head>
<body>
    
<!-- Loader Overlay -->
<div class="loader-overlay" id="loader" role="alert" aria-live="assertive" aria-label="Loading">
    <!-- Background Particle Animation -->
  

    <!-- Blockchain Animation -->
    <div class="blockchain">
      <div class="node"></div>
      <div class="node"></div>
      <div class="node"></div>
      <div class="node"></div>
      <div class="node"></div>
      <div class="node"></div>
      <div class="node"></div>
      <div class="node"></div>
    </div>
    <div class="loading-text"><center>Welcome to $lilstu website</center> <br> <center>A community driven project</center>
    </div>

    <!-- Optional Sparkles for Added Elegance -->
    <div class="sparkle"></div>
    <div class="sparkle"></div>
    <div class="sparkle"></div>
    <div class="sparkle"></div>
  </div>

  
  <!-- JavaScript to Handle Loader -->
  <script>
    // Wait for the entire page to load
    window.addEventListener('load', () => {
      // Set a timeout to hide the loader after 2 seconds
      setTimeout(() => {
        const loader = document.getElementById('loader');
        const mainContent = document.getElementById('mainContent');

        if (loader) {
          // Add the 'hidden' class to initiate the fade-out transition
          loader.classList.add('hidden');

          // After the transition duration, hide the loader and show the main content
          setTimeout(() => {
            loader.style.display = 'none';
            if (mainContent) {
              mainContent.classList.add('active');
            }
          }, 1000); // Match this duration with the CSS transition duration (1s)
        }
      }, 2000); // 2000 milliseconds = 2 seconds
    });
  </script>

    <!-- Interactive Background Canvas -->
    <canvas id="interactive-background"></canvas>
    
    
    <!-- Top Bar -->
    <header class="topbar" role="banner">
        <h1><a href="index.html">StuartLittleOnSol</a></h1>
        <div class="menu-toggle" aria-label="Toggle Navigation" aria-expanded="false" aria-controls="nav-links">☰</div>
        <nav class="nav-links" id="nav-links" aria-hidden="true">
            <a href="#features">Features</a>
            <a href="#tokenomics">Tokenomics</a>
            <a href="#map">Roadmap</a>
            <a href="#piechart">Token Distribution</a>
            <a href="#faq">FAQ</a>
            <a href="#contact">Contact</a>
           

            <!-- Social Links -->
            <a href="https://linktr.ee/lilstuart.chill" target="_blank" aria-label="Linktree">Social links
                <i class="fab fa-linktree"></i>
                <img src="linktree.png" alt="Linktree Logo" style="width: 15px; height: 15px; margin-left: 5px;">
            </a>
            <!-- Connect Wallet Button 
            <button id="connect-wallet" class="btn connect-wallet-btn">Connect Your Wallet</button>
              Disconnect Wallet Button (Initially Hidden) -->
            <button id="disconnect-wallet" class="btn disconnect-wallet-btn" style="display: none; margin-left: 10px;">Disconnect Wallet</button>
            <span id="wallet-address" class="wallet-address" style="margin-left: 10px; font-weight: bold;"></span>
        </nav>
        
    </header>
    
   
    <!-- Main Container -->
        <div class="main-container">
      <!--        <br>
        <h1 class="headline">
         <span class="presale-live">Presale is Live!</span>
            <button class="scroll-down-btn" onclick="document.querySelector('#presale').scrollIntoView({ behavior: 'smooth' });" aria-label="Scroll Down">
                Scroll Down
            </button>
        </h1>
    </div>

Stuart Little Coin Section -->
<!-- Stuart Little Coin Section -->
<section class="why-us-section" id="why_us">
    <div class="transparent-box">
        <h1>Why Stuart Little Coin?</h1>
        <p>
            Because just like Stuart was an easy pick for that family in the orphanage, 
            this coin will be an easy pick in the memecoin market. Who wouldn’t want to 
            invest in the mouse who stole hearts?
        </p>
        
        <center>
          
            <!-- Updated Button to Redirect Directly -->
            <a href="https://jup.ag/swap/BCsCQtpUN9bbJFWQNtmAvVeEa29af5KnKppX51rXez48-SOL" class="cta-button" target="_blank">Trade $lilstu</a><br>
     
          <!-- Chart Toggle Button -->
             <button id="toggle-chart-btn">Show Price Chart</button>
             <button id="toggle-chart-btn" onclick="window.open('https://dexscreener.com/solana/grhb4ck87hmwe6fvtcfeafupq12v5awgzlpoeananwjq', '_blank')">Go to DexScreener</button>

        </center>
           <!--Chart Container (Initially Hidden) -->
          <div class="price-chart-container" id="price-chart-container" style="display: none;">
              <!-- DexScreener Embed -->
              <div id="dexscreener-embed">
                  <iframe 
                   src="https://dexscreener.com/solana/GRhb4CK87hmWE6FVTCFEaFuPq12v5AwgzLPoEAnAnwJQ?embed=1&loadChartSettings=0&chartLeftToolbar=0&chartTheme=dark&theme=dark&chartStyle=0&chartType=usd&interval=15"
                      allowfullscreen>
                  </iframe>
              </div>
          </div>
   </div>
</section>

<style>
    /* Responsive Styling for the DexScreener Embed */
    #dexscreener-embed {
        position: relative;
        width: 100%;
        /* Increase this padding-bottom for a taller chart. 
           For example, 150% will make it taller than the original 125%. */
        padding-bottom: 150%; 
    }

    @media (min-width: 1400px) {
        #dexscreener-embed {
            /* Adjust this too for large screens */
            padding-bottom: 85%; 
        }
    }

    #dexscreener-embed iframe {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        border: 0;
    }
</style>

<script>
    // JavaScript for Toggling the Chart
    document.getElementById('toggle-chart-btn').addEventListener('click', function() {
        var chartContainer = document.getElementById('price-chart-container');
        if (chartContainer.style.display === 'none') {
            chartContainer.style.display = 'block';
            this.textContent = 'Hide Price Chart';
        } else {
            chartContainer.style.display = 'none';
            this.textContent = 'Show Price Chart';
        }
    });
</script>

        <main class="content">
            <!-- Hero Section with Stuart Image -->
            <section class="hero-section animate-on-scroll" id="home">
                
                <img src="stuart.jpg" alt="Stuart Little on Sol" class="hero-image" id="hero-image" loading="lazy">
            </section>
   <!--<section class="presale-section" id="video">
    <h2>How to get your $lilstu token during presale</h2>
            Integrated Video with Styling and Animation -->
   <!--<div class="presale-video animate__animated animate__fadeInUp">
  
    <iframe 
        src="https://www.youtube.com/embed/RB5lRbm0qjU" 
        title="$lilstu Presale Video" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;" 
        allowfullscreen>
    </iframe>
</div>-->
</section>
<br><br><br>
<div class="tic-tac-toe-container">
    <h2 class="game-title">Tic Tac Toe</h2>
    <div class="scoreboard">
        <p>Player: <span id="playerScore">0</span></p>
        <p>Computer: <span id="computerScore">0</span></p>
        <p>Ties: <span id="ties">0</span></p>
    </div>
    <div class="game-board" id="gameBoard">
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
        <div class="cell" data-cell></div>
    </div>
    <button class="reset-btn" id="resetButton">Reset Game</button>
</div>
<br> <br>
           <!-- Presale Information Section -->
   <!--  <section class="presale-section" id="presale">
        <h2>Presale Information</h2>
        <u><p><strong>Presale Softcap:</strong></u> 15 SOL (119 holders- 7 sol remaining)</p>
        <u><p><strong>Token Live:</u></strong> After presale ends</p>
        <u><p><strong>Anticipated Launch Date:</u></strong> 20 December 2024</p>

         Airdrop Vesting Period -->
       <!--   <div class="airdrop-vesting">
            <p><strong><u>Airdrop: Vesting Period</u></strong></p>
            <p>&bull; 70% will be airdropped one day before the launch</p><br>
            <p>&bull; 10% will be airdropped each day after the launch</p>
        </div> 

        <!- Contract Address with Copy Button -->
       <!--   <div class="contract-section">
            <p><strong><u>Contract Address</u></strong></p>
            <div class="copy-container">
                <div class="contract-address" id="contractAddress">
                    8ZPQsXxwrx6exd56EAmPdQy3yaSDwY7fCdnsRGaDetZU
                </div>
                <button class="copy-button" onclick="copyToClipboard()">Copy</button>
            </div>
            <span class="copy-success" id="copySuccess">Copied!</span>
        </div>

        <!-Socials Section -->

            <!--         <div class="social-links">
                    <!- Repeated Social Links for clarity -->
                      <!-- Social Links -->
              <!--   <a href="https://linktr.ee/lilstuart.chill" target="_blank" aria-label="Linktree">
                <i class="fab fa-linktree"></i>
                <img src="linktree.png" alt="Linktree Logo" style="width: 20px; height: 20px; margin-left: 5px;">
            </a>
                </div>
            </section>
            <br><br>
        
            
          <!-      Token Price Calculation Section -->
          <!--       <section class="presale-section" id="token-price">
                <h2>Token Price Calculator</h2>
                <p><strong>Current Token Price:</strong> 1 $lilstu = <span id="token-price-usd">Loading...</span> USD</p>
                <p><strong>Token Price in USDC:</strong> <span id="token-price-usdc">Loading...</span> USDC</p>
                <p><strong>Equivalent in SOL:</strong> <span id="token-price-sol">Loading...</span> SOL</p>
                <p><strong>USDC Price:</strong> <span id="usdc-price-usd">Loading...</span> USD</p>

                <!- Calculator Form -->
                <div class="calculator-container">
           <!--              <h3>Calculate Tokens You'll Receive</h3>
                    <form id="token-calculator" onsubmit="return false;">
                        <label for="amount-input">Enter Amount:</label>
                        <input type="number" id="amount-input" placeholder="Amount in SOL" min="0" step="any" required>
                        <select id="currency-select">
                         <!-  <option value="USDC">USDC</option>-->
                   <!--          <option value="SOL">SOL</option>
                        </select>
                        <button type="button" id="calculate-button">Calculate</button>
                        <br> 
                     <!-   <button type="button" id="buy-button" class="btn" disabled>Buy</button>-->
                    </form>
                    <p id="calculation-result"></p>
                </div>

               

                <!-- Confirmation Message Container -->
                <div id="transaction-confirmation" class="transaction-confirmation" style="display: none; margin-top: 20px;">
                    <p id="confirmation-message" style="color: green; font-weight: bold;"></p>
                </div>
            </section>

            <!-- Mobile Presale Section -->
        <!--    <div class="mobile-presale-section">
                <h2>Token Launch Information</h2>
                <p>Join the StuartLittleOnSol Presale launching on December 20th!</p>
                <div class="presale-content">
                    <!- Additional Content as Needed -->
           <!--       </div>
                <img src="token.png" alt="Token Image" class="token-image">
            </div>

            <!- Presale Popup (Initially Hidden) -->
            <div class="presale-popup" id="presale-popup" aria-labelledby="presale-title" role="dialog" aria-modal="true">
                <button class="close-btn" id="presale-close" aria-label="Close Presale Popup">&times;</button>
         <!--      <h2 id="presale-title">Token Launch Information</h2>
                <p>Join the StuartLittleOnSol Presale launching on December 20th!</p>

                <!- Countdown Timer -->
                <div class="countdown" id="countdown">
                    <div>
                        <span id="days">0</span>
                        Days
                    </div>
                    <div>
                        <span id="hours">0</span>
                        Hours
                    </div>
                    <div>
                        <span id="minutes">0</span>
                        Minutes
                    </div>
                    <div>
                        <span id="seconds">0</span>
                        Seconds
                    </div>
                </div>

                <!-- Token Image -->
                <img src="token.png" alt="Token Image" class="token-image" id="token-image">
            </div>

            <!-- Minimized Presale Popup -->
            <div class="presale-minimized" id="presale-minimized">
                   <button id="presale-minimized-btn" aria-label="Open Presale Popup">
               
                </button>
            </div>
            <br><br>

            <!-- Tokenomics Section with King Image -->
            <section class="tokenomics-section" id="tokenomics">
                <h2>Tokenomics</h2>
                <div class="tokenomics-container">
                    <div class="tokenomics-item">
                        <h3>Total Supply</h3>
                        <p>1,000,000,000 STUART</p>
                    </div>
                    <div class="tokenomics-item">
                        <h3>Public Sale</h3>
                        <p>30% of total supply allocated for public sale.</p>
                    </div>
                    <div class="tokenomics-item">
                        <h3>Dev and Management</h3>
                        <p>6% of total supply allocated to the development and management team.</p>
                    </div>
                    <div class="tokenomics-item">
                        <h3>Presale</h3>
                        <p>6% of total supply allocated for presale.</p>
                    </div>
                    <div class="tokenomics-item">
                        <h3>Marketing and Promotions</h3>
                        <p>6% of total supply allocated for marketing and promotions.</p>
                    </div>
                    <div class="tokenomics-item">
                        <h3>Airdrop (Contest)</h3>
                        <p>2% of total supply allocated for airdrops and contests.</p>
                    </div>
                    <div class="tokenomics-item">
                        <h3>Liquidity pool burn</h3>
                        <p>50% of the tokens will be permanently burnt to enhance price stability, trust, and long-term value.</p>
                    </div>
                </div>
                <!-- King Image within Tokenomics Section -->
                <img src="king.png" alt="King Image" class="king-image-tokenomics" id="king-image-tokenomics">
            </section>

            <!-- Pie Chart Section -->
            <section class="piechart-section" id="piechart">
                <h2>Token Distribution</h2>
                <div class="chart-container">
                    <canvas id="tokenomics-piechart"></canvas>
                </div>
                <div id="custom-legend" class="chart-legend"></div>
                
            </section>
            <!-- Fixed Thought Cloud -->
            <div class="thought-cloud-container">
                <div class="thought-cloud">
                    <div class="main-quote">
                        Just like Stuart found his perfect family, this coin will find its place in your portfolio. Invest in the mouse who captured hearts and now leads the market!

                    </div>
                    <div class="rotating-quote animate__animated animate__fadeInUp">
                        <em>Lil' Coin, Big Dreams, No Cap</em>
                    </div>
                    <!-- Button removed for automatic rotation -->
                </div>
            </div>
            <!--road map section-->
            
            <div class="container" id="map">

            <h2>Project Roadmap</h2>
                <div class="events">
                    <div class="event-wrapper" data-id="event-1">
                        <div class="event-dot" data-target="event-1"></div>
                        <div class="event-card" id="event-1">
                            <h3>Pre-Sale Ends (Dec 18)</h3>
                            <p>This marks the close of our presale round, setting the stage for the upcoming token distribution.</p>
                        </div>
                    </div>
                    <div class="event-wrapper" data-id="event-2">
                        <div class="event-dot" data-target="event-2"></div>
                        <div class="event-card" id="event-2">
                            <h3>Airdrop (Dec 18-23)</h3>
                            <p>Our token airdrop campaign runs from Dec 18 to Dec 23, rewarding early supporters.</p>
                        </div>
                    </div>
                    <div class="event-wrapper" data-id="event-3">
                        <div class="event-dot" data-target="event-3"></div>
                        <div class="event-card" id="event-3">
                            <h3>Launch (Dec 20)</h3>
                            <p>Official project launch on Dec 20 (Dex Screener, birdseye.so , raydium) making tokens available for public trading.</p>
                        </div>
                    </div>
                    <div class="event-wrapper" data-id="event-4">
                        <div class="event-dot" data-target="event-4"></div>
                        <div class="event-card" id="event-4">
                            <h3>KYC Audit Submission (Dec 25)</h3>
                            <p>Submission of KYC audit on Dec 25, ensuring trust and compliance for all participants.</p>
                        </div>
                    </div>
                    <div class="event-wrapper" data-id="event-5">
                        <div class="event-dot" data-target="event-5"></div>
                        <div class="event-card" id="event-5">
                            <h3>All DEX Listing (Dec 30)</h3>
                            <p>On Dec 30, our token will be listed on all major decentralized exchanges (DEX).</p>
                        </div>
                    </div>
                    <div class="event-wrapper" data-id="event-6">
                        <div class="event-dot" data-target="event-6"></div>
                        <div class="event-card" id="event-6">
                            <h3>CEX Listing (Feb 1)</h3>
                            <p>By Feb 1, we anticipate the token to be listed on major centralized exchanges (CEX).</p>
                        </div>
                    </div>
                </div>
                <div class="svg-container">
                    <svg id="timeline-svg" width="400" height="0" style="overflow: visible;">
                        <defs>
                            <linearGradient id="gradient" x1="0" y1="0" x2="0" y2="1">
                                <stop offset="0%" stop-color="#00f5c9" />
                                <stop offset="100%" stop-color="#00c9f5" />
                            </linearGradient>
                        </defs>
                        <path id="timeline-path" class="timeline-path"></path>
                    </svg>
                </div>
            </div>
            
            <!-- Features Section -->
            <section class="features-section animate-on-scroll" id="features">
                <h2>Features</h2>
                <div class="features-container">
                    <div class="feature-card">
                        <h3>Tax-Free Token</h3>
                        <p>This innovative approach is designed to offer a seamless experience for traders and investors while maintaining full transparency and compliance.</p>
                    </div>
                    <div class="feature-card">
                        <h3>Decentralized Memecoin</h3>
                        <p>Gain full control over your assets with a token on the Solana blockchain. StuartLittleOnSol ensures that your transactions are fast, transparent, and free from centralized oversight.</p>
                    </div>
                    <div class="feature-card">
                        <h3>Community Governance</h3>
                        <p>Be part of a thriving community where your voice matters. Participate in governance decisions through our transparent voting system and help shape the future direction of StuartLittleOnSol. With rewards for active participation, your engagement strengthens the ecosystem while benefiting all members.</p>
                    </div>
                </div>
            </section>

         <!-- FAQ Section -->
<section class="faq-section" id="faq">
    <h2>Frequently Asked Questions</h2>
    
    <div class="faq-container">
        <div class="faq-item">
            <h3>What is StuartLittleOnSol?</h3>
            <p>StuartLittleOnSol is a decentralized token designed for meme enthusiasts, offering secure transactions on Solana, community governance, and a vibrant ecosystem.</p>
        </div>
     
       
        <div class="faq-item">
            <h3>What blockchain is StuartLittleOnSol built on?</h3>
            <p>StuartLittleOnSol is built on the Solana blockchain, leveraging its robust infrastructure and low transaction fees.</p>
        </div>
        
        <div class="faq-item">
            <h3>What are the benefits of holding STUART tokens?</h3>
            <p>Holders of STUART tokens gain access to exclusive features, voting rights in community governance, and can earn rewards through airdrops and participation.</p>
        </div>
        
        <div class="faq-item">
            <h3>How long will I have to wait after we contact you?</h3>
            <p>We will get back to you within 2 hours.</p>
        </div>
        
    </div>
</section>


            <!-- Contact Section -->
             
            <section class="contact-section" id="contact">
                <h2>Contact Us</h2>
                <div class="sticky-note animate-on-scroll" aria-labelledby="contact-title">
                    <h3 id="contact-title">Get in Touch</h3><br>
                    <p>If you have any questions, feedback, or just want to say hi, feel free to reach out to us using the form below:</p><br>
                    <form id="contact-form" action="mailto:bitelder01@gmail.com" method="post" enctype="text/plain">
                        <input type="text" placeholder="Your Name" required aria-label="Your Name">
                        <input type="email" placeholder="Your Email" required aria-label="Your Email">
                        <textarea placeholder="Your Message" rows="5" required aria-label="Your Message"></textarea>
                        <button type="submit">Send Message</button>
                    </form>
                </div>
            </section>
        </main>
    </div>

    <!-- Disclaimer Section -->
    <section class="disclaimer-section" id="disclaimer">
        <p>By purchasing $LILSTU, you acknowledge that it is not a security or investment. The team is not liable for any potential losses or tax implications. LILSTU is a community-driven DeFi ecosystem, and you are solely responsible for understanding and complying with local laws and regulations.</p>
    </section>

    <!-- Footer -->
    <footer role="contentinfo">
        <p>&copy; 2024 StuartLittleOnSol. All Rights Reserved.</p>
    </footer>

    <!-- JavaScript for All Functionalities -->
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // =============================
            //      GLOBAL VARIABLES
            // =============================
            let solPriceInUsd = null;
            let usdcPriceInUsd = null;
            const tokenPriceInUsd = 0.0001; // Fixed token price in USD
            let connectedWallet = null; // Initialize as null

            // Assign global variables from CDN libraries
            const solanaWeb3 = window.solanaWeb3;
            const splToken = window.splToken;

            // =============================
            //       ELEMENT SELECTORS
            // =============================
            const presalePopup = document.getElementById("presale-popup");
            const presaleCloseBtn = document.getElementById("presale-close");
            const presaleMinimized = document.getElementById('presale-minimized');
            const presaleMinimizedBtn = document.getElementById('presale-minimized-btn');
            const countdownElement = document.getElementById("countdown");
            const kingImageTokenomics = document.getElementById("king-image-tokenomics");
            const tokenomicsSection = document.getElementById("tokenomics");
            const menuToggle = document.querySelector('.menu-toggle');
            const topbar = document.querySelector('.topbar');
            const calculateButton = document.getElementById('calculate-button');
            const amountInput = document.getElementById('amount-input');
            const currencySelect = document.getElementById('currency-select');
            const calculationResult = document.getElementById('calculation-result');
            const toggleChartBtn = document.getElementById('toggle-chart-btn');
            const chartContainer = document.getElementById('price-chart-container');
            const navLinks = document.querySelector('.nav-links');
            const connectWalletButton = document.getElementById('connect-wallet');
            const disconnectWalletButton = document.getElementById('disconnect-wallet');
            const walletAddressSpan = document.getElementById('wallet-address');
            const buyButton = document.getElementById('buy-button');
            const TARGET_ADDRESS = 'HU1CB5vbghpEAA3xhbiWzJsqgoVaTPDQXPD1xDNB6FRM';
            const USDC_MINT_ADDRESS = 'Es9vMFrzaCERDysjGogfjUq7VYQVv1cVg1oWBuHh35sL'; // Mainnet USDC Mint Address

            // =============================
            //      PRESALE POPUP CODE
            // =============================
            let presaleShown = false; // Flag to ensure popup is shown only once

            // Countdown Timer Setup
            const launchDate = new Date("December 20, 2024 00:00:00").getTime();

            const updateCountdown = () => {
                const now = new Date().getTime();
                const distance = launchDate - now;

                if (distance < 0) {
                    countdownElement.innerHTML = "<div>Presale Launched!</div>";
                    clearInterval(countdownInterval);
                    return;
                }

                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                document.getElementById("days").innerText = days;
                document.getElementById("hours").innerText = hours;
                document.getElementById("minutes").innerText = minutes;
                document.getElementById("seconds").innerText = seconds;
            };

            const countdownInterval = setInterval(updateCountdown, 1000);
            updateCountdown(); // Initial call

            // Function to show presale popup
        //    const showPresale = () => {
         //        if (!presaleShown) {
         //            presalePopup.classList.add("active");
          //           presalePopup.style.display = 'flex'; // Ensure it's displayed
          //           presaleShown = true;
          //           observer.disconnect(); // Stop observing after first trigger
          //       }
          //   };

            // Function to hide presale popup (minimize)
            const hidePresale = () => {
                // Add minimize animation
                presalePopup.classList.add('minimize');

                // After animation ends, hide popup and show minimized button
                presalePopup.addEventListener('animationend', function handler() {
                    presalePopup.classList.remove('active', 'minimize');
                    presalePopup.style.display = 'none';
                    presaleMinimized.style.display = 'block';
                    presalePopup.removeEventListener('animationend', handler);
                });
            };

           // Toggle mobile menu visibility
menuToggle.addEventListener('click', () => {
    const isExpanded = menuToggle.getAttribute('aria-expanded') === 'true';
    menuToggle.setAttribute('aria-expanded', !isExpanded);
    navLinks.classList.toggle('active');
    navLinks.setAttribute('aria-hidden', isExpanded);

    // Toggle the hamburger icon
    menuToggle.classList.toggle('open');
});

// Close the mobile menu when a menu item is clicked
const menuItems = document.querySelectorAll('.nav-links a'); // Select all menu links
menuItems.forEach(item => {
    item.addEventListener('click', () => {
        navLinks.classList.remove('active'); // Hide the menu
        menuToggle.setAttribute('aria-expanded', 'false'); // Update ARIA state
        menuToggle.classList.remove('open'); // Reset the hamburger icon
    });
});

// Function to maximize the popup from minimized state
const maximizePresale = () => {
    presalePopup.style.display = 'flex';
    presalePopup.classList.add('maximize');

    presalePopup.addEventListener('animationend', function handler() {
        presalePopup.classList.remove('maximize');
        presalePopup.classList.add('active');
        presalePopup.removeEventListener('animationend', handler);
    });

    presaleMinimized.style.display = 'none';
};

// Close button event
presaleCloseBtn.addEventListener("click", hidePresale);
// Minimized button click event
presaleMinimizedBtn.addEventListener('click', maximizePresale);

// Close popup when clicking outside of it (optional)
window.addEventListener("click", (e) => {
    if (
        presalePopup.classList.contains('active') && // Ensure popup is active
        !presalePopup.contains(e.target) && // Click not inside popup
        !presaleMinimized.contains(e.target) && // Click not on minimized button
        e.target !== presaleMinimizedBtn // Click not on the minimized button itself
    ) {
        hidePresale();
    }
});

// Intersection Observer to detect when Presale section is in view
const observerOptions = {
    root: null, // viewport
    rootMargin: '0px',
    threshold: 0.1 // Trigger when 10% of the Presale section is visible
};

const observerCallback = (entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            showPresale();
        }
    });
};

const observer = new IntersectionObserver(observerCallback, observerOptions);
const presaleSection = document.getElementById("presale");
if (presaleSection) {
    observer.observe(presaleSection);
}


            // =============================
            //    INTERACTIVE BACKGROUND
            // =============================
            const canvas = document.getElementById('interactive-background');
            const ctx = canvas.getContext('2d');
            let particlesArray = [];
            const numberOfParticles = 85; // Increased number for denser background
            const mouse = { x: null, y: null, radius: 150 }; // Increased radius for better interaction

            // Handle Canvas Resize
            const resizeCanvas = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            // =============================
    //      RESPONSIVE SETTINGS
    // =============================

    // Define color palette for particles
    const colorPalette = [
        'rgba(255, 215, 0, 0.8)',    // Gold
        'rgba(0, 255, 255, 0.8)',    // Cyan
        'rgba(255, 0, 255, 0.8)',    // Magenta
        'rgba(0, 255, 0, 0.8)',      // Lime
        'rgba(255, 165, 0, 0.8)',    // Orange
        'rgba(128, 0, 128, 0.8)'     // Purple
    ];


            // Handle Mouse Movement
            window.addEventListener('mousemove', (e) => {
                mouse.x = e.x;
                mouse.y = e.y;
            });
  
            // =============================
            //        TOUCH INTERACTION
            // =============================

            // Handle Touch Start
            window.addEventListener('touchstart', (e) => {
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouse.x = touch.clientX;
                    mouse.y = touch.clientY;
                }
            }, false);

            // Handle Touch Move
            window.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouse.x = touch.clientX;
                    mouse.y = touch.clientY;
                }
            }, false);

            // Handle Touch End and Touch Cancel
            window.addEventListener('touchend', () => {
                mouse.x = null;
                mouse.y = null;
            }, false);

            window.addEventListener('touchcancel', () => {
                mouse.x = null;
                mouse.y = null;
            }, false);

            // =============================
            //         PARTICLE CLASS
            // =============================

           // =============================
    //         PARTICLE CLASS
    // =============================

    class Particle {
        constructor(x, y, dx, dy, size, color, opacity) {
            this.x = x;
            this.y = y;
            this.dx = dx;
            this.dy = dy;
            this.size = size;
            this.color = color;
            this.opacity = opacity;
            this.originalColor = color; // Store original color
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color; // Use particle's color
            ctx.fill();
        }

        update() {
            this.x += this.dx;
            this.y += this.dy;

                    // Bounce off edges
                    if (this.x + this.size > canvas.width || this.x - this.size < 0) this.dx *= -1;
                    if (this.y + this.size > canvas.height || this.y - this.size < 0) this.dy *= -1;

                    // Move away from mouse or touch
                    if (mouse.x !== null && mouse.y !== null) { // Ensure mouse coordinates are valid
                        const dxMouse = mouse.x - this.x;
                        const dyMouse = mouse.y - this.y;
                        const distance = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);
                        if (distance < mouse.radius + this.size) {
                            const angle = Math.atan2(dyMouse, dxMouse);
                            const moveX = Math.cos(angle) * 5;
                            const moveY = Math.sin(angle) * 5;
                            this.x -= moveX;
                            this.y -= moveY;
                            // Change color on interaction
                    this.color = ' #00f5c9'; // White color when interacting
                
                        }else {
                    // Revert to original color if not interacting
                    this.color = this.originalColor;
                    }
                }
                    this.draw();
                }
            }

            // =============================
            //      INITIALIZE PARTICLES
            // =============================

            const initParticles = () => {
                particlesArray = [];
                for (let i = 0; i < numberOfParticles; i++) {
                    const size = Math.random() * 3 + 1;
                    const x = Math.random() * (canvas.width - size * 2) + size;
                    const y = Math.random() * (canvas.height - size * 2) + size;
                    const dx = (Math.random() * 1) - 0.5;
                    const dy = (Math.random() * 1) - 0.5;
                    const opacity = Math.random() * 0.5 + 0.3; // Variable opacity for depth
                    particlesArray.push(new Particle(x, y, dx, dy, size, 'gold', opacity));
                }
            };

            // =============================
            //    CONNECT PARTICLES
            // =============================

            const connectParticles = () => {
                for (let a = 0; a < particlesArray.length; a++) {
                    for (let b = a + 1; b < particlesArray.length; b++) {
                        const dx = particlesArray[a].x - particlesArray[b].x;
                        const dy = particlesArray[a].y - particlesArray[b].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 120) { // Increased distance for more connections
                            const opacity = 1 - distance / 120;
                            ctx.strokeStyle = `rgba(255,215,0,${opacity})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                            ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                            ctx.stroke();
                        }
                    }
                }
            };

            // =============================
            //       ANIMATE PARTICLES
            // =============================

            const animateParticles = () => {
                requestAnimationFrame(animateParticles);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particlesArray.forEach(particle => particle.update());
                connectParticles();
            };

            // =============================
            //       INITIALIZATION
            // =============================

            initParticles();
            animateParticles();

            // =============================
            //    FAQ TOGGLE FUNCTIONALITY
            // =============================
            const faqItems = document.querySelectorAll('.faq-item');
            faqItems.forEach(item => {
                item.addEventListener('click', () => {
                    item.classList.toggle('active');
                });
            });

            // =============================
            //  KING IMAGE INTERACTIVITY
            // =============================
            kingImageTokenomics.addEventListener('mousemove', (e) => {
                const rect = tokenomicsSection.getBoundingClientRect();
                const x = e.clientX - rect.left - rect.width / 2;
                const y = e.clientY - rect.top - rect.height / 2;

                // Normalize the values
                const maxOffset = 30; // Increased offset for better visibility
                const offsetX = (x / (rect.width / 2)) * maxOffset;
                const offsetY = (y / (rect.height / 2)) * maxOffset;

                // Apply the offset
                kingImageTokenomics.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(15deg)`;
            });

            kingImageTokenomics.addEventListener('mouseleave', () => {
                // Reset the position
                kingImageTokenomics.style.transform = `translate(0px, 0px) rotate(0deg)`;
            });

            const ctxPie = document.getElementById('tokenomics-piechart').getContext('2d');


            const tokenomicsPieChart = new Chart(ctxPie, {
                type: 'doughnut',
                data: {
                    labels: [
                        'Public Sale', 
                        'Dev & Management', 
                        'Presale', 
                        'Marketing & Promotions', 
                        'Airdrop (Contest)',
                        'Liquidity Pool Burn'
                    ],
                    datasets: [{
                        label: 'Token Distribution',
                        data: [30, 6, 6, 6, 2, 50], // Percentages
                        backgroundColor: [
                            'rgba(255, 215, 0, 0.9)',   // Public Sale - Gold
                            'rgba(30, 144, 255, 0.9)',  // Dev and Management - Dodger Blue
                            'rgba(220, 20, 60, 0.9)',   // Presale - Crimson
                            'rgba(0, 128, 128, 0.9)',   // Marketing and Promotions - Teal
                            'rgba(255, 165, 0, 0.9)',   // Airdrop (Contest) - Orange
                            'rgba(75, 0, 130, 0.9)'     // Liquidity Pool Burn - Indigo
                        ],
                        borderColor: [
                            'rgba(255, 215, 0, 1)',     // Gold
                            'rgba(30, 144, 255, 1)',    // Dodger Blue
                            'rgba(220, 20, 60, 1)',     // Crimson
                            'rgba(0, 128, 128, 1)',     // Teal
                            'rgba(255, 165, 0, 1)',     // Orange
                            'rgba(75, 0, 130, 1)'       // Indigo
                        ],
                        borderWidth: 2,
                        hoverOffset: 10
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    return `${label}: ${value}%`;
                                }
                            },
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#FFD700',
                            bodyColor: '#fff',
                            borderColor: '#FFD700',
                            borderWidth: 1,
                            cornerRadius: 10,
                        },
                        legend: {
                            display: true // Show default legend
                        },
                        title: {
                            display: false
                        },
                        animation: {
                            animateRotate: true,
                            animateScale: true
                        }
                    },
                    cutout: '50%', // Creates the doughnut effect
                    maintainAspectRatio: false
                }
            });

            // =============================
            //    TOKEN CALCULATOR CODE
            // =============================

            /**
             * Fetches real-time SOL and USDC prices in USD from CoinGecko and updates the DOM.
             */
            async function fetchPrices() {
                const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3/simple/price';
                const params = new URLSearchParams({
                    ids: 'solana,usd-coin',
                    vs_currencies: 'usd'
                });

                try {
                    const response = await fetch(`${COINGECKO_API_URL}?${params.toString()}`);
                    if (!response.ok) {
                        throw new Error(`CoinGecko API responded with status: ${response.status}`);
                    }

                    const data = await response.json();

                    // Assign fetched prices
                    solPriceInUsd = parseFloat(data.solana?.usd);
                    usdcPriceInUsd = parseFloat(data['usd-coin']?.usd);

                    // Validate the fetched prices
                    if (!isValidPrice(solPriceInUsd) || !isValidPrice(usdcPriceInUsd)) {
                        throw new Error('Invalid price data received from CoinGecko API.');
                    }

                    // Update the DOM elements for prices
                    updatePriceElements();

                } catch (error) {
                    console.error('Error fetching prices:', error);
                    displayPriceError();
                }
            }

            /**
             * Validates the price data.
             * @param {number} price 
             * @returns {boolean}
             */
            function isValidPrice(price) {
                return typeof price === 'number' && !isNaN(price) && price > 0;
            }

            /**
             * Updates the DOM elements with the latest prices.
             */
            function updatePriceElements() {
                // Update USDC price
                const usdcPriceElement = document.getElementById('usdc-price-usd');
                if (usdcPriceElement && usdcPriceInUsd !== null) {
                    usdcPriceElement.innerText = `$${usdcPriceInUsd.toFixed(4)}`;
                }

                // Update SOL price
                const solPriceElement = document.getElementById('sol-price-usd');
                if (solPriceElement && solPriceInUsd !== null) {
                    solPriceElement.innerText = `$${solPriceInUsd.toFixed(2)}`;
                }

                // Update Token price in USD
                const tokenPriceElement = document.getElementById('token-price-usd');
                if (tokenPriceElement && tokenPriceInUsd !== null) {
                    tokenPriceElement.innerText = `$${tokenPriceInUsd.toFixed(5)}`;
                }

                // Calculate and update token price in SOL and USDC
                if (solPriceInUsd && tokenPriceInUsd && usdcPriceInUsd) {
                    const tokenPriceInSol = (tokenPriceInUsd / solPriceInUsd).toFixed(8);
                    const tokenPriceInUsdc = (tokenPriceInUsd / usdcPriceInUsd).toFixed(8);

                    const priceSolElement = document.getElementById('token-price-sol');
                    if (priceSolElement) {
                        priceSolElement.innerText = `${tokenPriceInSol} SOL`;
                    }

                    const priceUsdcElement = document.getElementById('token-price-usdc');
                    if (priceUsdcElement) {
                        priceUsdcElement.innerText = `${tokenPriceInUsdc} USDC`;
                    }
                }
            }

            /**
             * Displays an error message in the price elements.
            
            function displayPriceError() {
                const priceElements = ['usdc-price-usd', 'sol-price-usd', 'token-price-usd', 'token-price-sol', 'token-price-usdc'];
                priceElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.innerText = 'Error fetching price';
                    }
                });
            }

            /**
             * Sets up the token calculator functionality.
             */
         /*   function setupTokenCalculator() {
                if (!calculateButton || !amountInput || !currencySelect || !calculationResult) {
                    console.error('One or more calculator elements are missing in the DOM.');
                    return;
                }

                calculateButton.addEventListener('click', () => {
                    // Clear previous result
                    calculationResult.innerText = '';

                    // Parse and sanitize user input
                    const amount = parseFloat(amountInput.value);
                    const currency = currencySelect.value;

                    // Input Validation
                    if (!isValidAmount(amount)) {
                        calculationResult.innerText = 'Please enter a valid positive amount.';
                        return;
                    }

                    if (!solPriceInUsd || !usdcPriceInUsd) {
                        calculationResult.innerText = 'Price data not loaded yet. Please try again in a moment.';
                        return;
                    }

                    let tokensReceived = 0;

                    // Simple calculation logic
                    if (currency === 'USDC') {
                        tokensReceived = amount / tokenPriceInUsd;
                    } else if (currency === 'SOL') {
                        const amountInUsd = amount * solPriceInUsd;
                        tokensReceived = amountInUsd / tokenPriceInUsd;
                    } else {
                        calculationResult.innerText = 'Unsupported currency selected.';
                        return;
                    }

                    // Ensure tokensReceived is a finite number
                    if (!isFinite(tokensReceived)) {
                        calculationResult.innerText = 'Calculation error. Please check your inputs.';
                        return;
                    }

                    // Display the result with comma separators and appropriate decimal places
                    calculationResult.innerText = `You will receive ${tokensReceived.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} STUART tokens.`;

                    // Enable Buy button if wallet is connected
                    if (connectedWallet) {
                        buyButton.disabled = false;
                    }
                });
            }
            */
            /**
             * Validates the input amount.
             * @param {number} amount 
             * @returns {boolean}
            
            function isValidAmount(amount) {
                return typeof amount === 'number' && !isNaN(amount) && amount > 0;
            }

            // Initialize Token Calculator
            setupTokenCalculator();
            fetchPrices(); // Initial fetch when the page loads
            // Update the prices every minute (60000 milliseconds)
            setInterval(fetchPrices, 60000);
 */
            // =============================
            //   SCROLL ANIMATIONS CODE
            // =============================
            const scrollAnimations = () => {
                const elements = document.querySelectorAll('.animate-on-scroll');
                elements.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    if (rect.top < window.innerHeight - 100) {
                        el.classList.add('visible');
                    }
                });
            };

            window.addEventListener('scroll', debounce(scrollAnimations));
            scrollAnimations(); // Initial call

            // =============================
            //    PRESALE POPUP RESIZE
            // =============================
            const adjustPopupSize = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;

                if (aspectRatio > 1.6) {
                    // Wide screens (e.g., 16:9 or wider)
                    presalePopup.style.width = '60vw';
                    presalePopup.style.maxWidth = '1200px';
                    presalePopup.style.padding = '50px';
                } else if (aspectRatio > 1.4) {
                    // Moderate wide screens (e.g., 3:2)
                    presalePopup.style.width = '70vw';
                    presalePopup.style.maxWidth = '1000px';
                    presalePopup.style.padding = '40px';
                } else {
                    // Square or tall screens
                    presalePopup.style.width = '80vw';
                    presalePopup.style.maxWidth = '800px';
                    presalePopup.style.padding = '30px';
                }
            };

            // Initial adjustment
            adjustPopupSize();

            // Adjust on window resize
            window.addEventListener('resize', adjustPopupSize);

            // =============================
            //      TRADINGVIEW WIDGET
            // =============================
            let chartInitialized = false;

            toggleChartBtn.addEventListener('click', () => {
                if (!chartInitialized) {
                    new TradingView.widget({
                        "width": "100%",
                        "height": 500,
                        "symbol": "BINANCE:SOLUSDT",
                        "interval": "D",
                        "timezone": "Etc/UTC",
                        "theme": "dark",
                        "style": "1",
                        "locale": "en",
                        "toolbar_bg": "#f1f3f6",
                        "enable_publishing": false,
                        "withdateranges": true,
                        "hide_side_toolbar": false,
                        "allow_symbol_change": true,
                        "container_id": "tradingview-widget"
                    });
                    chartInitialized = true;
                }

                if (chartContainer.style.display === 'none' || chartContainer.style.display === '') {
                    chartContainer.style.display = 'block';
                    toggleChartBtn.innerText = 'Hide Price Chart';
                } else {
                    chartContainer.style.display = 'none';
                    toggleChartBtn.innerText = 'Show Price Chart';
                }
            });

            // =============================
            //    CONNECT WALLET FUNCTIONALITY
            // =============================

            /**
             * Connects to the Phantom Wallet.
             */
            const connectWallet = async () => {
                if (window.solana && window.solana.isPhantom) {
                    try {
                        const response = await window.solana.connect({ onlyIfTrusted: false });
                        console.log('Connected wallet:', response.publicKey.toString());
                        connectedWallet = response.publicKey.toString();
                        walletAddressSpan.innerText = `Connected: ${truncateAddress(connectedWallet)}`;
                        connectWalletButton.disabled = true;
                        connectWalletButton.innerText = 'Wallet Connected';
                        disconnectWalletButton.style.display = 'inline-block'; // Show Disconnect button
                        console.log('Connected wallet address:', connectedWallet);
                        // Enable Buy button if calculation is already done
                        if (calculationResult.innerText.includes('STUART tokens')) {
                            buyButton.disabled = false;
                        }
                    } catch (err) {
                        console.error('Failed to connect wallet:', err);
                        alert('Failed to connect wallet. Please try again.');
                    }
                } else {
                    alert('Phantom Wallet not found. Please install it from https://phantom.app/download');
                }
            };

            /**
             * Truncates the wallet address for display.
             * @param {string} address 
             * @returns {string}
             */
            const truncateAddress = (address) => {
                return `${address.substring(0, 4)}...${address.substring(address.length - 4)}`;
            };

            // =============================
            //    DISCONNECT WALLET FUNCTIONALITY
            // =============================

            /**
             * Disconnects the Phantom Wallet.
             */
            const disconnectWallet = async () => {
                if (window.solana && window.solana.isPhantom && connectedWallet) {
                    try {
                        await window.solana.disconnect();
                        connectedWallet = null;
                        walletAddressSpan.innerText = '';
                        connectWalletButton.disabled = false;
                        connectWalletButton.innerText = 'Connect Your Wallet';
                        disconnectWalletButton.style.display = 'none'; // Hide Disconnect button
                        buyButton.disabled = true;
                        console.log('Wallet disconnected.');
                        // Display confirmation message
                        showConfirmationMessage('Wallet successfully disconnected.');
                    } catch (err) {
                        console.error('Failed to disconnect wallet:', err);
                        alert('Failed to disconnect wallet. Please try again.');
                    }
                }
            };

            // Event listener for Disconnect Wallet button
            disconnectWalletButton.addEventListener('click', disconnectWallet);

            // Event listener for Connect Wallet button
            connectWalletButton.addEventListener('click', connectWallet);

            // =============================
            //         BUY BUTTON CODE
            // =============================

            /**
             * Handles the Buy action by sending SOL or USDC to the target address.
             */
            const buyTokens = async () => {
                if (!connectedWallet) {
                    alert('Please connect your wallet first.');
                    return;
                }

                const amount = parseFloat(amountInput.value);
                const currency = currencySelect.value;

                if (!isValidAmount(amount)) {
                    alert('Please enter a valid amount.');
                    return;
                }

                try {
                    let signature;

                    if (currency === 'SOL') {
                        signature = await sendSOL(amount);
                    } else if (currency === 'USDC') {
                        signature = await sendUSDC(amount);
                    } else {
                        alert('Unsupported currency selected.');
                        return;
                    }

                    // Display confirmation message with Solscan link
                    showConfirmationMessage(`Successfully sent ${amount} ${currency} to ${TARGET_ADDRESS}. <a href="https://solscan.io/tx/${signature}?cluster=mainnet" target="_blank">View on Solscan</a>`);
                    // Reset the form
                    document.getElementById('token-calculator').reset();
                    calculationResult.innerText = '';
                    buyButton.disabled = true;
                } catch (error) {
                    console.error('Transaction failed:', error);
                    alert(`Transaction failed: ${error.message}`);
                }
            };

            // Event listener for Buy button
            buyButton.addEventListener('click', () => {
                // Add animation to buy action (assuming animate.css is included)
                buyButton.classList.add('animate__animated', 'animate__pulse');
                setTimeout(() => {
                    buyTokens();
                    buyButton.classList.remove('animate__animated', 'animate__pulse');
                }, 500);
            });

            /**
             * Sends SOL from the user's wallet to the target address.
             * @param {number} amount 
             * @returns {string} Transaction signature
             */
            const sendSOL = async (amount) => {
                const provider = window.solana;
                const fromPubkey = new solanaWeb3.PublicKey(connectedWallet);
                const toPubkey = new solanaWeb3.PublicKey(TARGET_ADDRESS);

                // Ensure lamports are integers
                const lamports = solanaWeb3.LAMPORTS_PER_SOL * amount;
                const roundedLamports = Math.round(lamports);

                // Initialize connection
                const CUSTOM_RPC_URL = 'https://mainnet.helius-rpc.com/?api-key=427fa942-d36b-460c-b857-4653ef42fc1a'; // Replace with your custom RPC URL

                // Initialize connection with custom RPC
                const connection = new solanaWeb3.Connection(CUSTOM_RPC_URL, 'confirmed');

                // Fetch recent blockhash
                const { blockhash } = await connection.getLatestBlockhash();

                const transaction = new solanaWeb3.Transaction({ recentBlockhash: blockhash, feePayer: fromPubkey }).add(
                    solanaWeb3.SystemProgram.transfer({
                        fromPubkey,
                        toPubkey,
                        lamports: roundedLamports,
                    })
                );

                // Sign and send transaction
                const signature = await provider.signAndSendTransaction(transaction);
                await connection.confirmTransaction(signature, 'confirmed');

                return signature; // Return the transaction signature
            };

            /**
             * Sends USDC (SPL Token) from the user's wallet to the target address.
             * @param {number} amount 
             * @returns {string} Transaction signature
             */
                      // Complete the sendUSDC function
                      const sendUSDC = async (amount) => {
                const provider = window.solana;
                const fromPubkey = new solanaWeb3.PublicKey(connectedWallet);
                const toPubkey = new solanaWeb3.PublicKey(TARGET_ADDRESS);

                // Get the token program ID
                const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');

                // Initialize connection
                const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl('mainnet-beta'), 'confirmed');

                // Find the associated token accounts
                const fromTokenAccount = await getOrCreateAssociatedTokenAccount(fromPubkey, USDC_MINT_ADDRESS, fromPubkey, connection);
                const toTokenAccount = await getOrCreateAssociatedTokenAccount(toPubkey, USDC_MINT_ADDRESS, toPubkey, connection);

                // Fetch recent blockhash
                const { blockhash } = await connection.getLatestBlockhash();

                // Create transfer instruction using @solana/spl-token
                const transaction = new solanaWeb3.Transaction({ recentBlockhash: blockhash, feePayer: fromPubkey }).add(
                    splToken.createTransferInstruction(
                        fromTokenAccount,
                        toTokenAccount,
                        fromPubkey,
                        amount * (10 ** 6), // USDC has 6 decimals
                        [],
                        TOKEN_PROGRAM_ID
                    )
                );

                // Sign and send transaction
                const signature = await provider.signAndSendTransaction(transaction);
                await connection.confirmTransaction(signature, 'confirmed');

                return signature; // Return the transaction signature
            };

            /**
             * Gets or creates the associated token account for a given owner and mint.
             * @param {PublicKey} owner 
             * @param {string} mint 
             * @param {PublicKey} payer 
             * @param {Connection} connection
             * @returns {PublicKey}
             */
            const getOrCreateAssociatedTokenAccount = async (owner, mint, payer, connection) => {
                const associatedTokenAddress = await splToken.getAssociatedTokenAddress(
                    splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
                    splToken.TOKEN_PROGRAM_ID,
                    new solanaWeb3.PublicKey(mint),
                    new solanaWeb3.PublicKey(owner)
                );

                // Check if the account exists
                const account = await connection.getAccountInfo(associatedTokenAddress);
                if (account === null) {
                    // Create the account
                    const transaction = new solanaWeb3.Transaction().add(
                        splToken.createAssociatedTokenAccountInstruction(
                            new solanaWeb3.PublicKey(payer), // Payer
                            associatedTokenAddress,         // Associated Token Account
                            new solanaWeb3.PublicKey(owner), // Owner
                            new solanaWeb3.PublicKey(mint)  // Mint
                        )
                    );
                    const signature = await window.solana.signAndSendTransaction(transaction);
                    await connection.confirmTransaction(signature, 'confirmed');
                }

                return associatedTokenAddress;
            };

            // =============================
            //    TRANSACTION CONFIRMATION MESSAGE
            // =============================

            /**
             * Displays a confirmation message to the user.
             * @param {string} message 
             */
            const showConfirmationMessage = (message) => {
                const confirmationContainer = document.getElementById('transaction-confirmation');
                const confirmationMessage = document.getElementById('confirmation-message');
                confirmationMessage.innerHTML = message;
                confirmationContainer.style.display = 'block';

                // Hide the message after 5 seconds
                setTimeout(() => {
                    confirmationContainer.style.display = 'none';
                }, 5000);
            };

            // =============================
            //   AUTOMATIC WALLET CONNECTION
            // =============================

            /**
             * Automatically connects to the wallet if already connected (persistent session).
             */
            const checkIfWalletIsConnected = async () => {
                if (window.solana && window.solana.isPhantom) {
                    try {
                        const response = await window.solana.connect({ onlyIfTrusted: true });
                        connectedWallet = response.publicKey.toString();
                        walletAddressSpan.innerText = `Connected: ${truncateAddress(connectedWallet)}`;
                        connectWalletButton.disabled = true;
                        connectWalletButton.innerText = 'Wallet Connected';
                        disconnectWalletButton.style.display = 'inline-block'; // Show Disconnect button
                        buyButton.disabled = false;
                        console.log('Wallet already connected:', connectedWallet);
                    } catch (err) {
                        console.log('No wallet connection found:', err);
                    }
                }
            };

            checkIfWalletIsConnected();

            // =============================
            //      DEBOUNCE FUNCTION
            // =============================
            /**
             * Debounce function to limit how often a function can fire.
             * @param {Function} func - The function to debounce.
             * @param {number} wait - The time to wait in milliseconds.
             * @returns {Function}
             */
            function debounce(func, wait = 200) {
                let timeout;
                return function (...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), wait);
                };
            }

            // =============================
            //      INTERACTIVE HEADING
            // =============================
            const heading = document.querySelector('h1');

            heading.addEventListener('mousemove', (e) => {
                const rect = heading.getBoundingClientRect();
                const xPos = e.clientX - rect.left;
                const percent = xPos / rect.width;
                const angle = Math.floor(percent * 180); 
                heading.style.setProperty('--underline-gradient', `linear-gradient(${angle}deg, #00f5c9, #00c9f5)`);
            });

            const style = document.createElement('style');
            style.innerHTML = `
                h1::after {
                    background: var(--underline-gradient, linear-gradient(to right, #00f5c9, #00c9f5));
                }
            `;
            document.head.appendChild(style);

        }); // End of DOMContentLoaded listener

        // =============================
        //      COPY TO CLIPBOARD
        // =============================
        function copyToClipboard() {
            const contractAddress = document.getElementById('contractAddress').innerText;

            // Check if the Clipboard API is available
            if (navigator.clipboard && window.isSecureContext) {
                // Use the modern Clipboard API
                navigator.clipboard.writeText(contractAddress).then(() => {
                    showCopySuccess();
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    fallbackCopyText(contractAddress);
                });
            } else {
                // Fallback to the older method
                fallbackCopyText(contractAddress);
            }
        }

        function fallbackCopyText(text) {
            // Create a temporary textarea element
            const textarea = document.createElement('textarea');
            textarea.value = text;
            // Make sure the textarea is not visible
            textarea.style.position = 'fixed';
            textarea.style.top = '-9999px';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopySuccess();
                } else {
                    console.error('Fallback: Copy command was unsuccessful');
                }
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }

            // Remove the temporary textarea
            document.body.removeChild(textarea);
        }

        function showCopySuccess() {
            const copySuccess = document.getElementById('copySuccess');
            copySuccess.style.display = 'block';
            // Hide after 2 seconds
            setTimeout(() => {
                copySuccess.style.display = 'none';
            }, 2000);
        }

      //  <!-- Automatic Quote Rotation Script -->

        const rotatingQuoteEl = document.querySelector('.thought-cloud .rotating-quote');
        
        const extraQuotes = [
    "As Stuart found his home, this coin will find its place in your wallet.",
    "Small coin, big impact – just like Stuart Little.",
    "Who says a mouse can’t move markets? Stuart proved it, so will this coin!",
    "Stuart stole hearts; this coin will steal the market.",
    "In a world of giants, the little ones make the biggest impact.",
    "A coin with charm and courage – Stuart Little would approve.",
    "Not about size; it’s about heart. That’s Stuart Little Coin.",
    "Stuart picked his family, and this coin is your perfect pick.",
    "In memecoins, Stuart Little Coin is the ultimate underdog.",
    "The mouse that won hearts inspires a coin to win the market.",
    "Stuart taught us: the best picks aren’t the biggest, but the smartest.",
    "From the orphanage to your wallet – the hero coin you need.",
    "Stuart stood out, and so does this coin in the market.",
    "Small start, great potential – Stuart Little Coin has it all.",
    "Stuart found the best family; this coin finds the best investors."
];



        let currentIndex = 0;
        const quoteChangeInterval = 10000; // 10 seconds

        function changeQuote() {
            currentIndex = (currentIndex + 1) % extraQuotes.length;
            // Add fade-out effect
            rotatingQuoteEl.classList.remove('animate__fadeInUp');
            rotatingQuoteEl.classList.add('animate__fadeOutDown');

            // Wait for fade-out to complete before changing the text
            setTimeout(() => {
                rotatingQuoteEl.innerHTML = `<em>${extraQuotes[currentIndex]}</em>`;
                // Remove fade-out and add fade-in effect
                rotatingQuoteEl.classList.remove('animate__fadeOutDown');
                rotatingQuoteEl.classList.add('animate__fadeInUp');
            }, 1000); // Match this duration with the CSS animation duration (1s)
        }

        // Initialize the first quote change after the interval
        setInterval(changeQuote, quoteChangeInterval);
    
       
        const heroSection = document.querySelector('.hero-section');
        const heroImage = document.getElementById('hero-image');

        // Function to handle mouse movement
        const handleMouseMove = (e) => {
            const rect = heroSection.getBoundingClientRect();
            const x = e.clientX - rect.left; // X position within the hero-section
            const y = e.clientY - rect.top;  // Y position within the hero-section

            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            // Calculate rotation values
            const rotateX = ((y - centerY) / centerY) * 10; // Max rotation of 10 degrees
            const rotateY = ((x - centerX) / centerX) * -10;

            // Apply rotation to the image
            heroImage.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.15)`;

            // Update glow position based on cursor
            const glowOffsetX = ((x - centerX) / centerX) * 10; // Adjust multiplier for effect
            const glowOffsetY = ((y - centerY) / centerY) * 10;

            heroImage.style.setProperty('--glow-x', `${glowOffsetX}px`);
            heroImage.style.setProperty('--glow-y', `${glowOffsetY}px`);
        };

        // Function to reset transformations
        const handleMouseLeave = () => {
            heroImage.style.transform = `scale(1)`;
            heroImage.style.setProperty('--glow-x', `0px`);
            heroImage.style.setProperty('--glow-y', `0px`);
        };

        // Attach event listeners
        heroSection.addEventListener('mousemove', handleMouseMove);
        heroSection.addEventListener('mouseleave', handleMouseLeave);
        const button = document.querySelector('.cta-button');

button.addEventListener('click', () => {
    button.classList.add('clicked');
    setTimeout(() => {
        button.classList.remove('clicked');
    }, 200); // Reset after 200ms
});
// DOM Elements
const gameBoard = document.getElementById('gameBoard');
const resetButton = document.getElementById('resetButton');
const playerScoreEl = document.getElementById('playerScore');
const computerScoreEl = document.getElementById('computerScore');
const tiesEl = document.getElementById('ties');
const cells = Array.from(document.querySelectorAll('[data-cell]'));

const ticTacToeContainer = document.querySelector('.tic-tac-toe-container');

// Game Variables
let playerScore = 0;
let computerScore = 0;
let ties = 0;

let currentPlayer = 'X';
let board = ['', '', '', '', '', '', '', '', ''];
const winningCombinations = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6]
];
const checkWin = (player) => {
    for (let combo of winningCombinations) {
        const [a, b, c] = combo;
        if (board[a] === player && board[b] === player && board[c] === player) {
            return combo; // Return the winning combination
        }
    }
    return null; // No win found
};
// Handle Cell Click
const handleClick = (e) => {
    const cell = e.target;
    const index = cells.indexOf(cell);

    if (board[index] !== '') return;

    placeMark(cell, currentPlayer);
    board[index] = currentPlayer;

    const winningCombo = checkWin(currentPlayer);
    if (winningCombo) {
        highlightWinningCells(winningCombo);
        setTimeout(() => endGame(`${currentPlayer} wins`), 1000); // Allow animation to play
        if (currentPlayer === 'X') playerScore++;
        else computerScore++;
        updateScores();
    } else if (board.every((mark) => mark !== '')) {
        setTimeout(() => endGame('Tie'), 500);
        ties++;
        updateScores();
    } else {
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        if (currentPlayer === 'O') {
            setTimeout(() => computerMove(), 2000); // 2-second delay for computer move
        }
    }
};

// Place Mark
const placeMark = (cell, mark) => {
    cell.textContent = mark;
    cell.classList.add('taken');
};

// Computer Move
const computerMove = () => {
    const emptyIndices = board
        .map((mark, index) => (mark === '' ? index : null))
        .filter((index) => index !== null);

    if (emptyIndices.length === 0) return; // No moves left

    // 1. Check if computer can win in the next move
    for (let index of emptyIndices) {
        board[index] = 'O';
        if (checkWin('O')) {
            placeMark(cells[index], 'O');
            handleMoveResult('O', index);
            return;
        }
        board[index] = ''; // Undo move
    }

    // 2. Check if player can win in their next move and block them
    for (let index of emptyIndices) {
        board[index] = 'X';
        if (checkWin('X')) {
            board[index] = 'O';
            placeMark(cells[index], 'O');
            handleMoveResult(null, index); // No immediate win for 'O'
            return;
        }
        board[index] = ''; // Undo move
    }

    // 3. Take the center if available
    const center = 4;
    if (emptyIndices.includes(center)) {
        placeMark(cells[center], 'O');
        board[center] = 'O';
        handleMoveResult(null, center);
        return;
    }

    // 4. Take one of the corners
    const corners = [0, 2, 6, 8];
    const availableCorners = corners.filter(index => emptyIndices.includes(index));
    if (availableCorners.length > 0) {
        const randomCorner = availableCorners[Math.floor(Math.random() * availableCorners.length)];
        placeMark(cells[randomCorner], 'O');
        board[randomCorner] = 'O';
        handleMoveResult(null, randomCorner);
        return;
    }

    // 5. Take any side
    const sides = [1, 3, 5, 7];
    const availableSides = sides.filter(index => emptyIndices.includes(index));
    if (availableSides.length > 0) {
        const randomSide = availableSides[Math.floor(Math.random() * availableSides.length)];
        placeMark(cells[randomSide], 'O');
        board[randomSide] = 'O';
        handleMoveResult(null, randomSide);
        return;
    }
};

// Helper function to handle the result after a move
const handleMoveResult = (winner, index) => {
    if (winner) {
        const winningCombo = checkWin(winner);
        if (winningCombo) {
            highlightWinningCells(winningCombo);
            setTimeout(() => endGame(`${winner} wins`), 1000);
            if (winner === 'O') {
                computerScore++;
            } else {
                playerScore++;
            }
            updateScores();
        }
    } else if (board.every((mark) => mark !== '')) {
        setTimeout(() => endGame('Tie'), 500);
        ties++;
        updateScores();
    } else {
        currentPlayer = 'X';
    }
};




// Highlight Winning Cells
const highlightWinningCells = (winningCombo) => {
    winningCombo.forEach((index) => {
        cells[index].classList.add('winning-cell');
    });
};

// End Game
const endGame = (result) => {
    alert(result);
    resetGame();
};

// Reset Game
const resetGame = () => {
    board = ['', '', '', '', '', '', '', '', ''];
    cells.forEach((cell) => {
        cell.textContent = '';
        cell.classList.remove('taken', 'winning-cell');
    });
    currentPlayer = 'X';
};

// Update Scores
const updateScores = () => {
    playerScoreEl.textContent = playerScore;
    computerScoreEl.textContent = computerScore;
    tiesEl.textContent = ties;
};

// Reset Button Event Listener
resetButton.addEventListener('click', resetGame);

// Cell Event Listeners
cells.forEach((cell) => cell.addEventListener('click', handleClick));

// Hamburger Menu Toggle for Floating Behavior
menuToggle.addEventListener('click', () => {
    ticTacToeContainer.classList.toggle('no-float');
});

    </script>
</body>
</html>

  
